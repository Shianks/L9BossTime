<script>
    // Update current time (GMT+8)
    function updateCurrentTime() {
        const now = new Date();
        // Create a date object in GMT+8 by adjusting the UTC time
        const gmt8Time = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Manila' }));
        document.getElementById('current-time').textContent =
            gmt8Time.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true }) +
            ' (' + gmt8Time.toLocaleDateString('en-US') + ')';
    }
    setInterval(updateCurrentTime, 1000);
    updateCurrentTime();

    // Set current time as kill time
    document.getElementById('set-current-time').addEventListener('click', function() {
        const now = new Date();
        // Get current time in Manila timezone and format for datetime-local
        const manilaTime = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Manila' }));
        const year = manilaTime.getFullYear();
        const month = String(manilaTime.getMonth() + 1).padStart(2, '0');
        const day = String(manilaTime.getDate()).padStart(2, '0');
        const hours = String(manilaTime.getHours()).padStart(2, '0');
        const minutes = String(manilaTime.getMinutes()).padStart(2, '0');
        const localDateTime = `${year}-${month}-${day}T${hours}:${minutes}`;

        document.getElementById('kill-time').value = localDateTime;
        updateSpawnPreview();
    });

    // Update spawn preview when values change
    document.getElementById('kill-time').addEventListener('change', updateSpawnPreview);
    document.getElementById('respawn-hours').addEventListener('input', updateSpawnPreview);
    document.getElementById('respawn-minutes').addEventListener('input', updateSpawnPreview);

    function updateSpawnPreview() {
        const killTimeInput = document.getElementById('kill-time').value;
        const respawnHours = parseInt(document.getElementById('respawn-hours').value) || 0;
        const respawnMinutes = parseInt(document.getElementById('respawn-minutes').value) || 0;

        if (killTimeInput && (respawnHours > 0 || respawnMinutes > 0)) {
            // Parse killTimeInput directly as a local time, assuming it's already GMT+8 from input.
            const killTime = new Date(killTimeInput);
            const totalMilliseconds = (respawnHours * 3600 + respawnMinutes * 60) * 1000;
            const spawnTime = new Date(killTime.getTime() + totalMilliseconds);

            document.getElementById('preview-kill-time').textContent = formatDateTime(killTime);
            document.getElementById('preview-spawn-time').textContent = formatDateTime(spawnTime);
            document.getElementById('spawn-preview').classList.remove('hidden');
        } else {
            document.getElementById('spawn-preview').classList.add('hidden');
        }
    }

    // Timer functionality
    let activeTimers = [];

    const LOCAL_STORAGE_KEY = 'bossTimers'; // Key for local storage

    function formatTime(seconds) {
        const hrs = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;
        return `${String(hrs).padStart(2, '0')}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }

    function formatShortTime(seconds) {
        const hrs = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        return `${hrs}h ${mins}m`;
    }

    // Modified formatDateTime to use 12-hour format with AM/PM for Philippine Time
    function formatDateTime(date) {
        return date.toLocaleTimeString('en-US', {
            hour: '2-digit',
            minute: '2-digit',
            hour12: true,
            timeZone: 'Asia/Manila' // Ensure it's formatted as Philippine Time
        }) + ' ' + date.toLocaleDateString('en-US', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            timeZone: 'Asia/Manila' // Ensure it's formatted as Philippine Time
        });
    }

    function saveTimers() {
        // We only want to save the 'bossData' part of each timer
        const timersToSave = activeTimers.map(timer => ({
            name: timer.bossData.name,
            level: timer.bossData.level,
            status: timer.bossData.status,
            hours: timer.bossData.hours,
            minutes: timer.bossData.minutes,
            // Convert Date object to ISO string for storage
            killTime: timer.bossData.killTime.toISOString()
        }));
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(timersToSave));
    }

    function loadTimers() {
        const savedTimers = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (savedTimers) {
            const parsedTimers = JSON.parse(savedTimers);
            parsedTimers.forEach(bossData => {
                // Convert killTime string back to Date object
                bossData.killTime = new Date(bossData.killTime);
                createTimer(bossData, true); // Pass true to indicate it's loading from storage
            });
        }
    }

    function updateTimers() {
        const now = Date.now();
        activeTimers.forEach(timer => {
            if (timer.active) {
                const remaining = Math.floor((timer.endTime - now) / 1000);
                if (remaining <= 0) {
                    timer.active = false;
                    timer.countdownEl.textContent = "SPAWNED!";
                    timer.countdownEl.classList.add('text-red-500', 'pulse');
                    timer.timeLeftEl.textContent = "BOSS IS UP!";
                    timer.timerElement.classList.add('completed');
                } else {
                    timer.countdownEl.textContent = formatTime(remaining);
                    timer.timeLeftEl.textContent = formatShortTime(remaining) + ' until spawn';
                }
            }
        });
        updateUpcomingTable();
    }

    // NEW FUNCTION: Update the upcoming bosses table
    function updateUpcomingTable() {
        const upcomingTableBody = document.getElementById('upcoming-bosses-table');
        upcomingTableBody.innerHTML = ''; // Clear the table

        // Filter for active timers and sort them by end time
        const upcomingBosses = activeTimers
            .filter(timer => timer.active)
            .sort((a, b) => a.endTime - b.endTime);

        upcomingBosses.forEach(timer => {
            const remaining = Math.floor((timer.endTime - Date.now()) / 1000);
            const row = document.createElement('tr');
            row.className = 'border-b border-gray-800 last:border-b-0';
            row.innerHTML = `
                <td class="py-2 pr-2 text-white font-bold">${timer.bossData.name}</td>
                <td class="py-2 text-right">${formatShortTime(remaining)}</td>
            `;
            upcomingTableBody.appendChild(row);
        });
    }

    // Modified createTimer to handle loading from storage
    function createTimer(bossData, isLoading = false) {
        const sampleTimer = document.getElementById('sample-timer');
        const newTimer = sampleTimer.cloneNode(true);
        newTimer.id = '';
        newTimer.classList.remove('hidden');

        // Set boss data
        newTimer.querySelector('[data-field="boss-name"]').textContent = bossData.name || 'Unknown Boss';
        newTimer.querySelector('[data-field="boss-level"]').textContent = `Lv. ${bossData.level || '?'}`;

        // Set status badge
        const statusEl = newTimer.querySelector('[data-field="boss-status"]');
        statusEl.textContent = bossData.status === 'confirmed' ? 'Confirmed' : 'Estimated';
        statusEl.className = `px-2 py-1 rounded text-xs ${bossData.status === 'confirmed' ? 'bg-green-700' : 'bg-yellow-700'}`;

        // Set respawn time
        newTimer.querySelector('[data-field="respawn-time"]').textContent =
            `${bossData.hours}h ${bossData.minutes}m`;

        // Calculate times
        // Ensure killTime is a Date object, especially when loading from local storage
        const killTime = new Date(bossData.killTime);
        const totalMilliseconds = (bossData.hours * 3600 + bossData.minutes * 60) * 1000;
        const spawnTime = new Date(killTime.getTime() + totalMilliseconds);

        // Set time displays
        newTimer.querySelector('[data-field="kill-time"]').textContent = formatDateTime(killTime);
        newTimer.querySelector('[data-field="next-spawn"]').textContent = formatDateTime(spawnTime);

        // Get elements for countdown
        const countdownEl = newTimer.querySelector('[data-field="countdown"]');
        const timeLeftEl = newTimer.querySelector('[data-field="time-left"]');

        // Add to DOM
        document.getElementById('timers-container').prepend(newTimer);

        // Store timer data
        const timerObj = {
            bossData,
            countdownEl,
            timeLeftEl,
            timerElement: newTimer,
            endTime: spawnTime.getTime(),
            totalMilliseconds: totalMilliseconds,
            active: true
        };

        activeTimers.push(timerObj);

        // Set up boss died button
        newTimer.querySelector('.boss-died-btn').addEventListener('click', function() {
            if (confirm('Reset timer with current time as new kill time?')) {
                // Get current time in Manila timezone
                const newKillTime = new Date(new Date().toLocaleString('en-US', { timeZone: 'Asia/Manila' }));
                const newSpawnTime = new Date(newKillTime.getTime() + timerObj.totalMilliseconds);

                // Update bossData killTime
                timerObj.bossData.killTime = newKillTime;

                // Update displays
                newTimer.querySelector('[data-field="kill-time"]').textContent = formatDateTime(newKillTime);
                newTimer.querySelector('[data-field="next-spawn"]').textContent = formatDateTime(newSpawnTime);

                // Reset timer
                timerObj.endTime = newSpawnTime.getTime();
                timerObj.active = true;
                timerObj.timerElement.classList.remove('completed');
                timerObj.countdownEl.classList.remove('text-red-500', 'pulse');
                timerObj.countdownEl.classList.add('flip');
                setTimeout(() => timerObj.countdownEl.classList.remove('flip'), 500);

                saveTimers(); // Save after updating a timer
            }
        });

        // Set up delete timer button
        newTimer.querySelector('.delete-timer-btn').addEventListener('click', function() {
            if (confirm('Are you sure you want to delete this timer?')) {
                newTimer.remove(); // Remove the timer's HTML element
                // Remove from activeTimers array
                activeTimers = activeTimers.filter(t => t !== timerObj);
                saveTimers(); // Save after deleting a timer
            }
        });

        // Initial animation only for newly created timers, not when loading from storage
        if (!isLoading) {
            countdownEl.classList.add('flip');
            setTimeout(() => countdownEl.classList.remove('flip'), 500);
            saveTimers(); // Save after creating a new timer
        }
    }

    // Start timer button
    document.getElementById('start-timer').addEventListener('click', function() {
        const bossName = document.getElementById('boss-name').value.trim() || 'Unknown Boss';
        const bossLevel = document.getElementById('boss-level').value;
        const bossStatus = document.getElementById('boss-status').value;
        const respawnHours = parseInt(document.getElementById('respawn-hours').value) || 0;
        const respawnMinutes = parseInt(document.getElementById('respawn-minutes').value) || 0;
        const killTimeInput = document.getElementById('kill-time').value;

        if (!killTimeInput) {
            alert('Please enter the kill time');
            return;
        }

        if (respawnHours <= 0 && respawnMinutes <= 0) {
            alert('Please enter a valid respawn time');
            return;
        }

        // Convert kill time to Date object
        // The datetime-local input gives a string in "YYYY-MM-DDTHH:MM" format.
        // When directly passed to new Date(), it's interpreted as local time.
        // Since we're setting it with a timezone-aware current time, this should be fine.
        const killTime = new Date(killTimeInput);

        createTimer({
            name: bossName,
            level: bossLevel,
            status: bossStatus,
            hours: respawnHours,
            minutes: respawnMinutes,
            killTime: killTime
        });

        // Optionally reset form after starting a timer
        document.getElementById('reset-form').click();
    });

    // Reset form button
    document.getElementById('reset-form').addEventListener('click', function() {
        document.getElementById('boss-name').value = '';
        document.getElementById('boss-level').value = '';
        document.getElementById('respawn-hours').value = '';
        document.getElementById('respawn-minutes').value = '';
        document.getElementById('kill-time').value = '';
        document.getElementById('boss-status').value = 'estimated';
        document.getElementById('spawn-preview').classList.add('hidden');
    });

    // Call loadTimers when the page loads
    window.addEventListener('load', loadTimers);

    // Update all timers every second
    setInterval(updateTimers, 1000);
</script>